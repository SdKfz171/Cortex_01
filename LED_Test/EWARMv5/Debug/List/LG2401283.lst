###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.4.54170/W32 for ARM     21/Jan/2015  23:02:52 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\2014년도 프로젝트\간단한                              #
#                    개발\voc_김한수박사\Firmware\TVOC_LCD_TGS_GPS_CDMA_SD_RT #
#                    C_Sen_141215\LG2401283.c                                 #
#    Command line =  "D:\2014년도 프로젝트\간단한                             #
#                    개발\voc_김한수박사\Firmware\TVOC_LCD_TGS_GPS_CDMA_SD_RT #
#                    C_Sen_141215\LG2401283.c" -D VECT_TAB_FLASH -lcN         #
#                    "D:\2014년도 프로젝트\간단한                             #
#                    개발\voc_김한수박사\Firmware\TVOC_LCD_TGS_GPS_CDMA_SD_RT #
#                    C_Sen_141215\EWARMv5\STM3210E-EVAL\List\" -o             #
#                    "D:\2014년도 프로젝트\간단한                             #
#                    개발\voc_김한수박사\Firmware\TVOC_LCD_TGS_GPS_CDMA_SD_RT #
#                    C_Sen_141215\EWARMv5\STM3210E-EVAL\Obj\" --debug         #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.4\arm\INC\c\DLib_Config_Full.h" -I           #
#                    "D:\2014년도 프로젝트\간단한                             #
#                    개발\voc_김한수박사\Firmware\TVOC_LCD_TGS_GPS_CDMA_SD_RT #
#                    C_Sen_141215\EWARMv5\..\" -I "D:\2014년도                #
#                    프로젝트\간단한 개발\voc_김한수박사\Firmware\TVOC_LCD_TG #
#                    S_GPS_CDMA_SD_RTC_Sen_141215\EWARMv5\..\..\" -I          #
#                    "D:\2014년도 프로젝트\간단한                             #
#                    개발\voc_김한수박사\Firmware\TVOC_LCD_TGS_GPS_CDMA_SD_RT #
#                    C_Sen_141215\EWARMv5\..\..\FWLib\library\inc\" -I        #
#                    "D:\2014년도 프로젝트\간단한                             #
#                    개발\voc_김한수박사\Firmware\TVOC_LCD_TGS_GPS_CDMA_SD_RT #
#                    C_Sen_141215\EWARMv5\..\..\01_drv\" -Ohz                 #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  D:\2014년도 프로젝트\간단한                              #
#                    개발\voc_김한수박사\Firmware\TVOC_LCD_TGS_GPS_CDMA_SD_RT #
#                    C_Sen_141215\EWARMv5\STM3210E-EVAL\List\LG2401283.lst    #
#    Object file  =  D:\2014년도 프로젝트\간단한                              #
#                    개발\voc_김한수박사\Firmware\TVOC_LCD_TGS_GPS_CDMA_SD_RT #
#                    C_Sen_141215\EWARMv5\STM3210E-EVAL\Obj\LG2401283.o       #
#                                                                             #
#                                                                             #
###############################################################################

D:\2014년도 프로젝트\간단한 개발\voc_김한수박사\Firmware\TVOC_LCD_TGS_GPS_CDMA_SD_RTC_Sen_141215\LG2401283.c
      1          #include "stm32f10x_it.h"
      2          #include "stm32f10x_spi.h"
      3          #include "stm32f10x_rcc.h"
      4          
      5          #include "font.h"
      6          
      7          
      8          void SendCtrl(u8 Cmd);
      9          void SendData(u8 Cmd);
     10          void delay_tst(u8 k);
     11          void setcursor(u8 x,u8 y);
     12          void lcd_init(void);
     13          void clr_screen(void);
     14          void dis_all(void);
     15          void dis_dot(void);
     16          void dis_col(void);
     17          void one_word(u8 x,u8 y,u8 *Lib,u8 ch_num,u8 widthw);
     18          void dis_logo(void);
     19          void dis_volt(u8 x, u8 y, u8 temp2, u8 temp1, u8 temp0);
     20          void dis_measure(void); 
     21          void DIS_ADC(u8 x, u8 y, u8 temp4,u8 temp3, u8 temp2,u8 temp1);
     22          void DIS_Volt(void);
     23          void DIS_GPS_NO(void);
     24          void DIS_CLEAR_GPS_NO(void);
     25          void DIS_GPS_TIME(unsigned char hour10,unsigned char hour1,unsigned char min10,unsigned char min1,unsigned char sec10,unsigned char sec1);
     26          void DIS_RTC_TIME(unsigned char hour10,unsigned char hour1,unsigned char min10,unsigned char min1,unsigned char sec10,unsigned char sec1);
     27          void DIS_number(u8 x, u8 y, u8 temp1);
     28          void DIS_Menu(void);
     29          void DIS_Measure_ou(void);
     30          void DIS_Normal_Set_Menu(void);
     31          void DIS_High_Set_Menu(void);
     32          void DIS_Mos_set_Menu(void);
     33          void DIS_TGS_LEVEL(u8 x, u8 y, u8 temp2,u8 temp1, u8 pos);
     34          void DIS_blink(u8 x, u8 y);
     35          void dis_res(u8 x, u8 y, u8 temp2, u8 temp1, u8 temp0);
     36          void DIS_TGS_Base(u8 x, u8 y, u8 temp4, u8 temp3, u8 temp2, u8 temp1, u8 pos);
     37          void DIS_ready(void);
     38          void DIS_run(void);
     39          void DIS_FUN_VOC(void);
     40          void Dis_OLUF(u8 x, u8 y, u8 temp4, u8 temp3, u8 temp2, u8 temp1 , u8 blink_pos);	
     41          void DIS_TGS_abcde(u8 x, u8 y, u8 temp7, u8 temp6, u8 temp5, u8 temp4, u8 temp3, u8 temp2, u8 temp1, u8 blink_pos);
     42          void DIS_ou(u8 x, u8 y, u8 temp5, u8 temp4, u8 temp3, u8 temp2, u8 temp1, u8 temp0);
     43          void DIS_ppb(u8 x, u8 y, u8 temp5, u8 temp4, u8 temp3, u8 temp2, u8 temp1, u8 temp0);
     44          
     45          void dis_temp(u8 x, u8 y, u8 temp2, u8 temp1, u8 temp0);
     46          void dis_humi(u8 x, u8 y, u8 temp2, u8 temp1, u8 temp0);
     47          
     48          void dis_sign(u8 x, u8 y, u8 val);
     49          
     50          void DIS_Comm_Set(void);
     51          void DIS_CDMA_Set(void);
     52          void DIS_normal(void);
     53          void DIS_abnormal(void);
     54          void Dis_CDMA_Time(u8 x, u8 y, u8 temp3, u8 temp2, u8 temp1, u8 blink_pos);
     55          void Dis_CDMA_Num(u8 x, u8 y, u8 temp11, u8 temp10, u8 temp9, u8 temp8, u8 temp7, u8 temp6, u8 temp5, u8 temp4, u8 temp3, u8 temp2, u8 temp1, u8 blink_pos); 
     56          void DIS_PV_Set(void);
     57          void Dis_Sample_Time(u8 x, u8 y, u8 temp3, u8 temp2, u8 temp1, u8 blink_pos);
     58          void DIS_Measure_m(void);
     59          void DIS_real_m(void);
     60          void DIS_duration_m(void);
     61          void DIS_continue_m(void);
     62          void DIS_ol(u8 x, u8 y, u8 temp5, u8 temp4, u8 temp3, u8 temp2, u8 temp1);
     63          void DIS_continue(void);
     64          void DIS_duration(void);
     65          void DIS_real(void);
     66          void Dis_Timer3(u8 temp3, u8 temp2, u8 temp1);
     67          void DIS_Time_Set(void);
     68          void DIS_RTC_SET(int i_year, int i_month, int i_day, int i_hour, int i_min, int i_sec, u8 blink_pos);
     69          void DIS_Modify_set_Menu(void);
     70          
     71          void DIS_FUN_TBM(void);
     72          void DIS_FUN_H2S(void);
     73          void DIS_FUN_NH3(void);
     74          void DIS_FUN_PID(void);
     75          
     76          extern void SPI_Normal_mode(void);
     77          extern void SPI_Spi_mode(void);
     78          extern void Delay(vu32 nCount);
     79          
     80          extern u8 T_toggle;
     81          
     82          void SendCtrl(u8 Cmd)
     83          {
     84             u32 j;
     85             	 //SPI_NSSInternalSoftwareConfig(SPI1 , SPI_NSSInternalSoft_Set);
     86             
     87                   SPI_Normal_mode();
     88                   GPIO_SetBits(GPIOA , GPIO_Pin_6);    // CS is High
     89                   
     90                   GPIO_SetBits(GPIOA , GPIO_Pin_5);    // CLK  high
     91                   for(j=0;j<=10;j++);
     92                   
     93                   GPIO_ResetBits(GPIOA , GPIO_Pin_7);  // SDA  low --> Command
     94                   GPIO_ResetBits(GPIOA , GPIO_Pin_5);    // CLK  low
     95                   for(j=0;j<=100;j++);      
     96                   GPIO_ResetBits(GPIOA , GPIO_Pin_5);    // CLK  low
     97                   for(j=0;j<=100;j++);           
     98                   GPIO_ResetBits(GPIOA , GPIO_Pin_5);    // CLK  low            
     99                   GPIO_SetBits(GPIOA , GPIO_Pin_5);    // CLK  high         
    100                   
    101                   
    102                   SPI_Spi_mode();
    103                   SPI_I2S_SendData(SPI1 , Cmd);
    104          	 while(SPI_I2S_GetFlagStatus(SPI1 , SPI_I2S_FLAG_BSY)|(!SPI_I2S_GetFlagStatus(SPI1 , SPI_I2S_FLAG_TXE))|SPI_I2S_GetFlagStatus(SPI1 , SPI_I2S_FLAG_OVR))	;
    105          
    106                   GPIO_ResetBits(GPIOA , GPIO_Pin_6);    // CS is low         
    107                   
    108                   //SPI_NSSInternalSoftwareConfig(SPI1 , SPI_NSSInternalSoft_Reset);
    109          }
    110          
    111          void SendData(u8 Cmd)
    112          {
    113                   u32 j;	
    114            
    115                   SPI_Normal_mode();
    116                   GPIO_SetBits(GPIOA , GPIO_Pin_6);    // CS is High
    117                   
    118                   GPIO_SetBits(GPIOA , GPIO_Pin_5);    // CLK  high
    119                   for(j=0;j<=10;j++);
    120                   
    121                   GPIO_SetBits(GPIOA , GPIO_Pin_7);      // SDA  high --> data
    122                   GPIO_ResetBits(GPIOA , GPIO_Pin_5);    // CLK  low
    123                   for(j=0;j<=100;j++);      
    124                   GPIO_ResetBits(GPIOA , GPIO_Pin_5);    // CLK  low
    125                   for(j=0;j<=100;j++);           
    126                   GPIO_ResetBits(GPIOA , GPIO_Pin_5);    // CLK  low            
    127                   GPIO_SetBits(GPIOA , GPIO_Pin_5);    // CLK  high         
    128                   
    129                   
    130                   SPI_Spi_mode();
    131               
    132               
    133               
    134               
    135               SPI_I2S_SendData(SPI1 , Cmd);
    136               while(SPI_I2S_GetFlagStatus(SPI1 , SPI_I2S_FLAG_BSY)|(!SPI_I2S_GetFlagStatus(SPI1 , SPI_I2S_FLAG_TXE))|SPI_I2S_GetFlagStatus(SPI1 , SPI_I2S_FLAG_OVR))	;
    137               
    138               GPIO_ResetBits(GPIOA , GPIO_Pin_6);
    139          	 //SPI_NSSInternalSoftwareConfig(SPI1 , SPI_NSSInternalSoft_Reset);
    140          }
    141          
    142          
    143          void delay_tst(u8 k)
    144          {
    145               u16 j;
    146          	 u8  i;
    147          	 for(i=0;i<=k;i++)
    148          	 {
    149          	     for(j=0;j<=60000;j++);
    150          	 }
    151          }
    152          
    153          void setcursor(u8 x,u8 y)
    154          {  	
    155             	SendCtrl(x|0xB0);					
    156          	SendCtrl(y>>4|0x10);				
    157             	SendCtrl(y&0x0F|0x00);
    158          }
    159          
    160          void lcd_init(void)					    
    161          	{
    162          		
    163          		u32 i;
    164          		//delay_tst(50);
    165          		//for(i=0;i<=2000000;i++);
    166          
    167                          for(i=0;i<5;i++);
    168                          
    169          		SendCtrl(0xE2);		  //Reset LCD
    170          		//for(i=0;i<=2000000;i++); 
    171                          Delay(50000);  
    172                          Delay(50000);  
    173                          
    174                          
    175                         
    176          		SendCtrl(0x26);           // Temperature compensation
    177          		SendCtrl(0x2D);           // Power control
    178                          for(i=0;i<=2000000;i++);                 
    179          		SendCtrl(0xEA);           // Bias ratio
    180          		SendCtrl(0x81);           // Set Gain
    181          		//contrast();                
    182          		SendCtrl(0x91);
    183                          
    184          		SendCtrl(0x40);            // set start line
    185          		SendCtrl(0x10);            // set column address MSB
    186          		SendCtrl(0x00);            // set column address LSB
    187          		SendCtrl(0x89);
    188                         
    189          		SendCtrl(0xC8);             // set LCD Mapping control
    190          		SendCtrl(0xAF);             // Set Display Enable
    191                          
    192          
    193                          
    194          	}
    195          /*
    196          void contrast(void)
    197          	{
    198          		switch(P2)
    199          		{
    200          			case 0xFE: 
    201          				wr_ctrl(0x8b); break;
    202          			case 0xFD: 
    203          				wr_ctrl(0x97); break;
    204          			case 0xFB: 
    205          				wr_ctrl(0xA2); break;
    206          			case 0xF7: 
    207          				wr_ctrl(0x6f); break;
    208          			case 0xEF: 
    209          				wr_ctrl(0x62); break;
    210          		}
    211          	}
    212          	*/
    213          
    214          void clr_screen(void)
    215          	{
    216          		u8 x,y;
    217          
    218          		for(x=0;x<16;x++)			
    219          		{
    220          			setcursor(x,0);
    221          			for(y=0;y<120;y++) 		   
    222          			{
    223          				SendData(0x00);			
    224          				SendData(0x00);
    225          			}
    226          		}
    227          	}
    228          
    229          
    230          /*****************************************************
    231          Initial Screen : AIRWORKS LOGO
    232          *****************************************************/
    233          void dis_logo(void)
    234          {
    235             u8 x,y;
    236          
    237             for(x=0;x<16;x++){
    238                setcursor(x,0);          // X position
    239                
    240                for(y=0;y<240;y++){
    241          	 SendData(LOGO_1[y+x*240]);
    242                }
    243             }
    244          }
    245          
    246          /*****************************************************
    247              Sensor Test 
    248          *****************************************************/
    249          
    250          void dis_measure(void)
    251          {
    252             u8 x,y;
    253          
    254             for(x=0;x<16;x++){
    255                setcursor(x,0);          // X position
    256                
    257                for(y=0;y<240;y++){
    258          	 SendData(sensor_m[y+x*240]);
    259                }
    260             }
    261          }
    262          
    263          /*****************************************************
    264              Sensor Test 
    265          *****************************************************/
    266          void DIS_Volt(void)
    267          {
    268             u8 x,y;
    269          
    270             for(x=0;x<16;x++){
    271                setcursor(x,0);          // X position
    272                
    273                for(y=0;y<240;y++){
    274          	   SendData(sensor_volt[y+x*240]);
    275                }
    276             }
    277          }
    278          
    279          void DIS_Measure_ou(void)
    280          {
    281             u8 x,y;
    282          
    283             for(x=0;x<16;x++){
    284                setcursor(x,0);          // X position
    285                
    286                for(y=0;y<240;y++){
    287          	 	SendData(sensor_ou_2[y+x*240]);
    288                }
    289             }
    290          }
    291          
    292          void DIS_Menu(void)
    293          {
    294             u8 x,y;
    295          
    296             for(x=0;x<16;x++){
    297                setcursor(x,0);          // X position
    298                
    299                for(y=0;y<240;y++){
    300          	 SendData(menu[y+x*240]);
    301                }
    302             }
    303          }
    304          
    305          void DIS_PV_Set(void)
    306          {
    307             u8 x,y;
    308          
    309             for(x=0;x<16;x++){
    310                setcursor(x,0);          // X position
    311                
    312                for(y=0;y<240;y++){
    313          	 SendData(PV_Set[y+x*240]);
    314                }
    315             }
    316          }
    317          
    318          
    319          /*****************************************************
    320              Plus minus 기호 표시 
    321          *****************************************************/
    322          
    323          void dis_sign(u8 x, u8 y, u8 val)
    324          {
    325               u8 i,j;
    326          
    327               if(val){
    328             	     for(i=0; i<2; i++){
    329                	     setcursor(x+i,y);          // X position
    330                	     for(j=0; j<6; j++){
    331          	     	     SendData(Plus[j+i*6]);
    332                	     }
    333          		}
    334          	}
    335          	else{       //minus
    336             	     for(i=0; i<2; i++){
    337                	     setcursor(x+i,y);          // X position
    338                	     for(j=0; j<6; j++){
    339          	     	     SendData(Plus[j+i*6+12]);
    340                	     }
    341          		}
    342          	  
    343          	}
    344          }
    345          
    346          /************************************************************************
    347           일반설정 --> 측정방법 설정 
    348          ************************************************************************/
    349          
    350          void DIS_Measure_m(void)
    351          {
    352             u8 x,y;
    353          
    354             for(x=0;x<16;x++){
    355                setcursor(x,0);          // X position
    356                
    357                for(y=0;y<240;y++){
    358          	 SendData(measure_m[y+x*240]);
    359                }
    360             }
    361          }
    362          
    363          
    364          // 일반설정 --> 측정방법설정 --> 실시간측정
    365          void DIS_real_m(void)
    366          {
    367             u8 x,y;
    368          
    369             for(x=0;x<4;x++){
    370                setcursor((x+2),124);          // X position      
    371                for(y=0;y<47;y++){
    372                     SendData(real_m[y+x*47]);
    373                }
    374             }
    375          }
    376          
    377          // 일반설정 --> 측정방법설정 --> 주기측정
    378          void DIS_duration_m(void)
    379          {
    380             u8 x,y;
    381          
    382             for(x=0;x<4;x++){
    383                setcursor((x+2),124);          // X position      
    384                for(y=0;y<47;y++){
    385                     SendData(duration_m[y+x*47]);
    386                }
    387             }
    388          }
    389          void DIS_continue_m(void)
    390          {
    391             u8 x,y;
    392          
    393             for(x=0;x<4;x++){
    394                setcursor((x+2),124);          // X position      
    395                for(y=0;y<47;y++){
    396                     SendData(continue_m[y+x*47]);
    397                }
    398             }
    399          }
    400          
    401          /**************  측정 화면에서 '실시간' 표시  ********************************/
    402          void DIS_real(void)
    403          {
    404             u8 x,y;
    405          
    406             for(x=0;x<2;x++){
    407                setcursor((x+14),7);          // X position      
    408                for(y=0;y<45;y++){
    409                     SendData(real[y+x*45]);
    410                }
    411             }
    412          }
    413          
    414          /**************  측정 화면에서 '주기' 표시  ********************************/
    415          void DIS_duration(void)
    416          {
    417             u8 x,y;
    418          
    419             for(x=0;x<2;x++){
    420                setcursor((x+14),7);          // X position      
    421                for(y=0;y<45;y++){
    422                     SendData(duration[y+x*45]);
    423                }
    424             }
    425          }
    426          
    427          /**************  측정 화면에서 '연속' 표시  ********************************/
    428          void DIS_continue(void)
    429          {
    430             u8 x,y;
    431          
    432             for(x=0;x<2;x++){
    433                setcursor((x+14), 7);          // X position      
    434                for(y=0;y<45;y++){
    435                     SendData(continue_1[y+x*45]);
    436                }
    437             }
    438          }
    439          
    440          void Dis_Timer3(u8 temp3, u8 temp2, u8 temp1)
    441          {
    442               unsigned char i, j;  
    443               u8 x_tap;
    444               u8 y=60;
    445             
    446               x_tap=1;
    447          
    448               for(i=0; i<2; i++){                         
    449                   setcursor(14+(x_tap*i), y);
    450                   for(j=(temp3*16); j<(temp3*16)+8; j++)
    451                        SendData(num[j+i*8]);
    452               }	
    453               for(i=0; i<2; i++){                         
    454                   setcursor(14+(x_tap*i), y+8);
    455                   for(j=(temp2*16); j<(temp2*16)+8; j++)
    456                        SendData(num[j+i*8]);
    457               }
    458               for(i=0; i<2; i++){                         
    459                    setcursor(14+(x_tap*i), y+(8*2));
    460                    for(j=(temp1*16); j<(temp1*16)+8; j++)
    461                         SendData(num[j+i*8]);
    462               }  
    463               
    464          }
    465          
    466          
    467          
    468          /************************************************************************
    469           일반설정 --> 동작시간 설정 
    470          ************************************************************************/
    471          void Dis_Sample_Time(u8 x, u8 y, u8 temp3, u8 temp2, u8 temp1, u8 blink_pos)
    472          {
    473               unsigned char i, j;  
    474               u8 x_tap, a;
    475             
    476               x_tap=1;
    477               a=0;
    478          
    479               for(i=0; i<2; i++){                         
    480                   setcursor(x+(x_tap*i), y);
    481                   for(j=(temp3*16); j<(temp3*16)+8; j++)
    482                        SendData(num[j+i*8]);
    483               }	
    484               for(i=0; i<2; i++){                         
    485                   setcursor(x+(x_tap*i), y+8);
    486                   for(j=(temp2*16); j<(temp2*16)+8; j++)
    487                        SendData(num[j+i*8]);
    488               }
    489               for(i=0; i<2; i++){                         
    490                    setcursor(x+(x_tap*i), y+(8*2));
    491                    for(j=(temp1*16); j<(temp1*16)+8; j++)
    492                         SendData(num[j+i*8]);
    493               }  
    494               
    495               
    496               if(blink_pos==1){  
    497                    for(i=0; i<2; i++){                         
    498                         setcursor(x+(x_tap*i), y+(8*2));
    499                         for(j=(temp1*16); j<(temp1*16)+8; j++){
    500                              if(T_toggle)SendData(num[j+i*8]);
    501                              else SendData(num[180+(a++)]);
    502                         }
    503                    }  
    504               }
    505               if(blink_pos==2){  
    506                    for(i=0; i<2; i++){                         
    507                        setcursor(x+(x_tap*i), y+8);
    508                        for(j=(temp2*16); j<(temp2*16)+8; j++){
    509                              if(T_toggle)SendData(num[j+i*8]);
    510                              else SendData(num[180+(a++)]);
    511                         }
    512                    }  
    513               } 
    514                if(blink_pos==3){  
    515                    for(i=0; i<2; i++){                         
    516                        setcursor(x+(x_tap*i), y);
    517                        for(j=(temp3*16); j<(temp3*16)+8; j++){
    518                              if(T_toggle)SendData(num[j+i*8]);
    519                              else SendData(num[180+(a++)]);
    520                         }
    521                    }  
    522               }    
    523          }
    524          
    525          
    526          // 고급 설정 -->  통신환경설정 화면 
    527          void DIS_Comm_Set(void)
    528          {
    529             u8 x,y;
    530          
    531             for(x=0;x<16;x++){
    532                setcursor(x,0);          // X position
    533                
    534                for(y=0;y<240;y++){
    535          	 SendData(comm_set[y+x*240]);
    536                }
    537             }
    538          }
    539          
    540          
    541          
    542          // 측정 준비  Message 표시 
    543          void DIS_ready(void)
    544          {
    545             u8 x,y;
    546          
    547             for(x=0;x<2;x++){
    548                setcursor(x,180);          // X position      
    549                for(y=0;y<48;y++){
    550                     SendData(m_ready[y+x*48]);
    551                }
    552             }
    553          }
    554          
    555          // 측정  Message 표시 
    556          void DIS_run(void)
    557          {
    558             u8 x,y;
    559          
    560             for(x=0;x<2;x++){
    561                setcursor(x,180);          // X position      
    562                for(y=0;y<48;y++){
    563                     SendData(m_run[y+x*48]);
    564                }
    565             }
    566          }
    567          
    568          // 정상  
    569          void DIS_normal(void)
    570          {
    571             u8 x,y;
    572          
    573             for(x=0;x<2;x++){
    574                setcursor(x+6,70);          // X position      
    575                for(y=0;y<50;y++){
    576                     SendData(normal[y+x*50]);
    577                }
    578             }
    579          }
    580          
    581          // 이상   
    582          void DIS_abnormal(void)
    583          {
    584             u8 x,y;
    585          
    586             for(x=0;x<2;x++){
    587                setcursor(x+6,70);          // X position      
    588                for(y=0;y<50;y++){
    589                     SendData(abnormal[y+x*50]);
    590                }
    591             }
    592          }
    593          
    594          void DIS_Normal_Set_Menu(void)
    595          {
    596             u8 x,y;
    597          
    598             for(x=0;x<16;x++){
    599                setcursor(x,0);          // X position
    600                
    601                for(y=0;y<240;y++){
    602          	 SendData(Normal_menu[y+x*240]);
    603                }
    604             }
    605          }
    606          
    607          void DIS_High_Set_Menu(void)
    608          {
    609             u8 x,y;
    610          
    611             for(x=0;x<16;x++){
    612                setcursor(x,0);          // X position
    613                
    614                for(y=0;y<240;y++){
    615          	 SendData(High_menu[y+x*240]);
    616                }
    617             }
    618          }
    619          
    620          void DIS_Mos_set_Menu(void)
    621          {
    622             u8 x,y;
    623          
    624             for(x=0;x<16;x++){
    625                setcursor(x,0);          // X position
    626                
    627                for(y=0;y<240;y++){
    628          	 SendData(mos_set[y+x*240]);
    629                }
    630             }
    631          }
    632          
    633          
    634          
    635          
    636          /***************************************************
    637           교정식 설정을 위한 함수
    638          ****************************************************/
    639          
    640          // 교정식 설정 메인 메뉴
    641          void DIS_Modify_set_Menu(void)
    642          {
    643             u8 x,y;
    644          
    645             for(x=0;x<16;x++){
    646                setcursor(x,0);          // X position
    647                
    648                for(y=0;y<240;y++){
    649          	 SendData(modify_menu[y+x*240]);
    650                }
    651             }
    652          }
    653          
    654          // TGS2602 교정식 설정 화면 
    655          void DIS_FUN_VOC(void)
    656          {
    657             u8 x,y;
    658          
    659             for(x=0;x<16;x++){
    660                setcursor(x,0);          // X position
    661                
    662                for(y=0;y<240;y++){
    663          	 SendData(fun_voc[y+x*240]);
    664                }
    665             }
    666          }
    667          
    668          void DIS_FUN_H2S(void)
    669          {
    670             u8 x,y;
    671          
    672             for(x=0;x<16;x++){
    673                setcursor(x,0);          // X position
    674                
    675                for(y=0;y<240;y++){
    676          	 SendData(fun_H2S[y+x*240]);
    677                }
    678             }
    679          }
    680          
    681          void DIS_FUN_NH3(void)
    682          {
    683             u8 x,y;
    684          
    685             for(x=0;x<16;x++){
    686                setcursor(x,0);          // X position
    687                
    688                for(y=0;y<240;y++){
    689          	 SendData(fun_NH3[y+x*240]);
    690                }
    691             }
    692          }
    693          
    694          void DIS_FUN_TBM(void)
    695          {
    696             u8 x,y;
    697          
    698             for(x=0;x<16;x++){
    699                setcursor(x,0);          // X position
    700                
    701                for(y=0;y<240;y++){
    702          	 	SendData(fun_TBM[y+x*240]);
    703                }
    704             }
    705          }
    706          
    707          void DIS_FUN_PID(void)
    708          {
    709             u8 x,y;
    710          
    711             for(x=0;x<16;x++){
    712                setcursor(x,0);          // X position
    713                
    714                for(y=0;y<240;y++){
    715          	 	SendData(fun_PID[y+x*240]);
    716                }
    717             }
    718          }
    719          
    720          void Dis_OLUF(u8 x, u8 y, u8 temp4, u8 temp3, u8 temp2, u8 temp1, u8 blink_pos)
    721          {
    722             unsigned char i, j;  
    723             u8 x_tap, a;
    724             
    725             a=0;
    726             x_tap=1;
    727             
    728           //  if(blink_pos==0){
    729             	  for(i=0; i<2; i++){                         
    730                 	setcursor(x+(x_tap*i), y);
    731                 	for(j=(temp4*16); j<(temp4*16)+8; j++)
    732                    	  SendData(num[j+i*8]);
    733             	  }	
    734          
    735          	  for(i=0; i<2; i++){                         
    736               	  setcursor(x+(x_tap*i), y+8);
    737          	       for(j=(temp3*16); j<(temp3*16)+8; j++)
    738               	       SendData(num[j+i*8]);
    739            	  }
    740            	  for(i=0; i<2; i++){                         
    741                 	setcursor(x+(x_tap*i), y+(8*2));
    742                 	for(j=160; j<168; j++)
    743                    	 SendData(num[j+i*8]);
    744             	  }  
    745             	  for(i=0; i<2; i++){                         
    746                 	setcursor(x+(x_tap*i), y+(8*2)+6);
    747                 	for(j=(temp2*16); j<(temp2*16)+8; j++)
    748                    	  SendData(num[j+i*8]);
    749             	  }
    750             	  for(i=0; i<2; i++){                         
    751                 	setcursor(x+(x_tap*i), y+(8*3)+6);
    752                 	for(j=(temp1*16); j<(temp1*16)+8; j++)
    753                      SendData(num[j+i*8]);
    754             	  }
    755           //  }  
    756             if(blink_pos==1){
    757             	  for(i=0; i<2; i++){                         
    758                 	setcursor(x+(x_tap*i), y+(8*3)+6);
    759                 	for(j=(temp1*16); j<(temp1*16)+8; j++){
    760          		     if(T_toggle)SendData(num[j+i*8]);
    761          		     else SendData(num[180+(a++)]);
    762          		}
    763             	  }	
    764             }
    765             else if(blink_pos==2){
    766             	  for(i=0; i<2; i++){                         
    767                 	setcursor(x+(x_tap*i), y+(8*2)+6);
    768                 	for(j=(temp2*16); j<(temp2*16)+8; j++){
    769          		     if(T_toggle)SendData(num[j+i*8]);
    770          		     else SendData(num[180+(a++)]);
    771          		}
    772             	  }	
    773             }
    774             else if(blink_pos==3){
    775             	  for(i=0; i<2; i++){                         
    776               	  setcursor(x+(x_tap*i), y+8);
    777          	       for(j=(temp3*16); j<(temp3*16)+8; j++){
    778          		     if(T_toggle)SendData(num[j+i*8]);
    779          		     else SendData(num[180+(a++)]);
    780          		}
    781             	  }	
    782             }
    783             else if(blink_pos==4){
    784             	  for(i=0; i<2; i++){                         
    785                 	setcursor(x+(x_tap*i), y);
    786                 	for(j=(temp4*16); j<(temp4*16)+8; j++){
    787          		     if(T_toggle)SendData(num[j+i*8]);
    788          		     else SendData(num[180+(a++)]);
    789          		}
    790             	  }	
    791             }
    792             
    793          }
    794          
    795          void DIS_TGS_abcde(u8 x, u8 y, u8 temp7, u8 temp6, u8 temp5, u8 temp4, u8 temp3, u8 temp2, u8 temp1, u8 blink_pos)
    796          {
    797             unsigned char i, j;  
    798             u8 x_tap, a;
    799             
    800             x_tap=1;
    801             a=0;
    802          
    803             for(i=0; i<2; i++){                         
    804                 setcursor(x+(x_tap*i), y);
    805                 for(j=(temp7*16); j<(temp7*16)+8; j++)
    806                      SendData(num[j+i*8]);
    807             }	
    808             for(i=0; i<2; i++){                         
    809                 setcursor(x+(x_tap*i), y+8);
    810                 for(j=(temp6*16); j<(temp6*16)+8; j++)
    811                      SendData(num[j+i*8]);
    812            }
    813             for(i=0; i<2; i++){                         
    814                 setcursor(x+(x_tap*i), y+(8*2));
    815                 for(j=(temp5*16); j<(temp5*16)+8; j++)
    816                      SendData(num[j+i*8]);
    817            }
    818            
    819            for(i=0; i<2; i++){                         
    820                 setcursor(x+(x_tap*i), y+(8*3));
    821                 for(j=160; j<168; j++)
    822                     SendData(num[j+i*8]);
    823             }  
    824             for(i=0; i<2; i++){                         
    825                 setcursor(x+(x_tap*i), y+(8*3)+6);
    826                 for(j=(temp4*16); j<(temp4*16)+8; j++)
    827                      SendData(num[j+i*8]);
    828             }
    829             for(i=0; i<2; i++){                         
    830                 setcursor(x+(x_tap*i), y+(8*4)+6);
    831                 for(j=(temp3*16); j<(temp3*16)+8; j++)
    832                      SendData(num[j+i*8]);
    833             }  
    834             for(i=0; i<2; i++){                         
    835                 setcursor(x+(x_tap*i), y+(8*5)+6);
    836                 for(j=(temp2*16); j<(temp2*16)+8; j++)
    837                      SendData(num[j+i*8]);
    838             }
    839             for(i=0; i<2; i++){                         
    840                 setcursor(x+(x_tap*i), y+(8*6)+6);
    841                 for(j=(temp1*16); j<(temp1*16)+8; j++)
    842                      SendData(num[j+i*8]);
    843             }    
    844            
    845            
    846              if(blink_pos==1){  
    847          	    for(i=0; i<2; i++){                         
    848                        setcursor(x+(x_tap*i), y+(8*6)+6);
    849                        for(j=(temp1*16); j<(temp1*16)+8; j++){
    850                             if(T_toggle) SendData(num[j+i*8]);
    851          			    else SendData(num[180+(a++)]);
    852          		    }
    853          	    }
    854              }
    855              else if(blink_pos==2){  
    856          	    for(i=0; i<2; i++){                         
    857                        setcursor(x+(x_tap*i), y+(8*5)+6);
    858                        for(j=(temp2*16); j<(temp2*16)+8; j++){
    859                             if(T_toggle) SendData(num[j+i*8]);
    860          			    else SendData(num[180+(a++)]);
    861          		    }
    862          	    }
    863              }
    864              else if(blink_pos==3){  
    865          	    for(i=0; i<2; i++){                         
    866                        setcursor(x+(x_tap*i), y+(8*4)+6);
    867          		    for(j=(temp3*16); j<(temp3*16)+8; j++){
    868                             if(T_toggle) SendData(num[j+i*8]);
    869          			    else SendData(num[180+(a++)]);
    870          		    }
    871          	    }
    872              } 
    873              else if(blink_pos==4){  
    874          	    for(i=0; i<2; i++){                         
    875                        setcursor(x+(x_tap*i), y+(8*3)+6);
    876          		    for(j=(temp4*16); j<(temp4*16)+8; j++){
    877                             if(T_toggle) SendData(num[j+i*8]);
    878          			    else SendData(num[180+(a++)]);
    879          		    }
    880          	    }
    881              }
    882          	else if(blink_pos==5){  
    883          	    for(i=0; i<2; i++){                         
    884                        setcursor(x+(x_tap*i), y+(8*2));
    885          		    for(j=(temp5*16); j<(temp5*16)+8; j++){
    886                             if(T_toggle) SendData(num[j+i*8]);
    887          			    else SendData(num[180+(a++)]);
    888          		    }
    889          	    }
    890              } 
    891              else if(blink_pos==6){  
    892          	    for(i=0; i<2; i++){                         
    893                        setcursor(x+(x_tap*i), y+8);
    894          		    for(j=(temp6*16); j<(temp6*16)+8; j++){
    895                             if(T_toggle) SendData(num[j+i*8]);
    896          			    else SendData(num[180+(a++)]);
    897          		    }
    898          	    }
    899              }
    900              else if(blink_pos==7){  
    901          	    for(i=0; i<2; i++){                         
    902                        setcursor(x+(x_tap*i), y);
    903          		    for(j=(temp7*16); j<(temp7*16)+8; j++){
    904                                   if(T_toggle) SendData(num[j+i*8]);
    905          			 else SendData(num[180+(a++)]);
    906          		    }
    907          	    }
    908              }  
    909          }
    910          
    911          /************************************************************************
    912            CDMA 전송 주기 표시 
    913          ************************************************************************/
    914          void Dis_CDMA_Time(u8 x, u8 y, u8 temp3, u8 temp2, u8 temp1, u8 blink_pos)
    915          {
    916               unsigned char i, j;  
    917               u8 x_tap, a;
    918             
    919               x_tap=1;
    920               a=0;
    921          
    922               for(i=0; i<2; i++){                         
    923                   setcursor(x+(x_tap*i), y);
    924                   for(j=(temp3*16); j<(temp3*16)+8; j++)
    925                        SendData(num[j+i*8]);
    926               }	
    927               for(i=0; i<2; i++){                         
    928                   setcursor(x+(x_tap*i), y+8);
    929                   for(j=(temp2*16); j<(temp2*16)+8; j++)
    930                        SendData(num[j+i*8]);
    931               }
    932               for(i=0; i<2; i++){                         
    933                    setcursor(x+(x_tap*i), y+(8*2));
    934                    for(j=(temp1*16); j<(temp1*16)+8; j++)
    935                         SendData(num[j+i*8]);
    936               }  
    937               if(blink_pos==1){  
    938                    for(i=0; i<2; i++){                         
    939                         setcursor(x+(x_tap*i), y+(8*2));
    940                         for(j=(temp1*16); j<(temp1*16)+8; j++){
    941                              if(T_toggle)SendData(num[j+i*8]);
    942                              else SendData(num[180+(a++)]);
    943                         }
    944                    }  
    945               }
    946               if(blink_pos==2){  
    947                    for(i=0; i<2; i++){                         
    948                        setcursor(x+(x_tap*i), y+8);
    949                        for(j=(temp2*16); j<(temp2*16)+8; j++){
    950                              if(T_toggle)SendData(num[j+i*8]);
    951                              else SendData(num[180+(a++)]);
    952                         }
    953                    }  
    954               } 
    955                if(blink_pos==3){  
    956                    for(i=0; i<2; i++){                         
    957                        setcursor(x+(x_tap*i), y);
    958                        for(j=(temp3*16); j<(temp3*16)+8; j++){
    959                              if(T_toggle)SendData(num[j+i*8]);
    960                              else SendData(num[180+(a++)]);
    961                         }
    962                    }  
    963               }    
    964          }
    965          
    966          /************************************************************************
    967            CDMA 전송 전화 번호 표시 
    968          ************************************************************************/
    969          void Dis_CDMA_Num(u8 x, u8 y, u8 temp11, u8 temp10, u8 temp9, u8 temp8, u8 temp7, u8 temp6, u8 temp5, u8 temp4, u8 temp3, u8 temp2, u8 temp1, u8 blink_pos)
    970          {
    971               unsigned char i, j;  
    972               u8 x_tap, a;
    973             
    974               x_tap=1;
    975               a=0;
    976          
    977               for(i=0; i<2; i++){                         
    978                   setcursor(x+(x_tap*i), y);
    979                   for(j=(temp11*16); j<(temp11*16)+8; j++)
    980                        SendData(num[j+i*8]);
    981               }	
    982               for(i=0; i<2; i++){                         
    983                   setcursor(x+(x_tap*i), y+8);
    984                   for(j=(temp10*16); j<(temp10*16)+8; j++)
    985                        SendData(num[j+i*8]);
    986               }
    987               for(i=0; i<2; i++){                         
    988                    setcursor(x+(x_tap*i), y+(8*2));
    989                    for(j=(temp9*16); j<(temp9*16)+8; j++)
    990                         SendData(num[j+i*8]);
    991               }  
    992               for(i=0; i<2; i++){                              // -                       
    993                    setcursor(x+(x_tap*i), y+(8*3)+2);
    994                    for(j=196; j<202; j++)
    995                         SendData(num[j+i*6]);
    996               }  
    997               for(i=0; i<2; i++){                         
    998                   setcursor(x+(x_tap*i), y+(8*4)+2);
    999                   for(j=(temp8*16); j<(temp8*16)+8; j++)
   1000                        SendData(num[j+i*8]);
   1001               }	
   1002               for(i=0; i<2; i++){                         
   1003                   setcursor(x+(x_tap*i), y+(8*5)+2);
   1004                   for(j=(temp7*16); j<(temp7*16)+8; j++)
   1005                        SendData(num[j+i*8]);
   1006               }
   1007               for(i=0; i<2; i++){                         
   1008                    setcursor(x+(x_tap*i), y+(8*6)+2);
   1009                    for(j=(temp6*16); j<(temp6*16)+8; j++)
   1010                         SendData(num[j+i*8]);
   1011               } 
   1012               for(i=0; i<2; i++){                         
   1013                    setcursor(x+(x_tap*i), y+(8*7)+2);
   1014                    for(j=(temp5*16); j<(temp5*16)+8; j++)
   1015                         SendData(num[j+i*8]);
   1016               } 
   1017               for(i=0; i<2; i++){                              // -                       
   1018                    setcursor(x+(x_tap*i), y+(8*8)+4);
   1019                    for(j=196; j<202; j++)
   1020                         SendData(num[j+i*6]);
   1021               }
   1022               for(i=0; i<2; i++){                         
   1023                   setcursor(x+(x_tap*i), y+(8*9)+4);
   1024                   for(j=(temp4*16); j<(temp4*16)+8; j++)
   1025                        SendData(num[j+i*8]);
   1026               }	
   1027               for(i=0; i<2; i++){                         
   1028                   setcursor(x+(x_tap*i), y+(8*10)+4);
   1029                   for(j=(temp3*16); j<(temp3*16)+8; j++)
   1030                        SendData(num[j+i*8]);
   1031               }
   1032               for(i=0; i<2; i++){                         
   1033                    setcursor(x+(x_tap*i), y+(8*11)+4);
   1034                    for(j=(temp2*16); j<(temp2*16)+8; j++)
   1035                         SendData(num[j+i*8]);
   1036               } 
   1037               for(i=0; i<2; i++){                         
   1038                    setcursor(x+(x_tap*i), y+(8*12)+4);
   1039                    for(j=(temp1*16); j<(temp1*16)+8; j++)
   1040                         SendData(num[j+i*8]);
   1041               } 
   1042          
   1043               if(blink_pos==1){  
   1044                    for(i=0; i<2; i++){                         
   1045                         setcursor(x+(x_tap*i), y+(8*12)+4);
   1046                         for(j=(temp1*16); j<(temp1*16)+8; j++){
   1047                              if(T_toggle)SendData(num[j+i*8]);
   1048                              else SendData(num[180+(a++)]);
   1049                         }
   1050                    }  
   1051               }
   1052               else if(blink_pos==2){  
   1053                    for(i=0; i<2; i++){                         
   1054                         setcursor(x+(x_tap*i), y+(8*11)+4);
   1055                         for(j=(temp2*16); j<(temp2*16)+8; j++){
   1056                              if(T_toggle)SendData(num[j+i*8]);
   1057                              else SendData(num[180+(a++)]);
   1058                         }
   1059                    }  
   1060               }
   1061               else if(blink_pos==3){  
   1062                    for(i=0; i<2; i++){                         
   1063                         setcursor(x+(x_tap*i), y+(8*10)+4);
   1064                         for(j=(temp3*16); j<(temp3*16)+8; j++){
   1065                              if(T_toggle)SendData(num[j+i*8]);
   1066                              else SendData(num[180+(a++)]);
   1067                         }
   1068                    }  
   1069               }
   1070               else if(blink_pos==4){  
   1071                    for(i=0; i<2; i++){                         
   1072                         setcursor(x+(x_tap*i), y+(8*9)+4);
   1073                         for(j=(temp4*16); j<(temp4*16)+8; j++){
   1074                              if(T_toggle)SendData(num[j+i*8]);
   1075                              else SendData(num[180+(a++)]);
   1076                         }
   1077                    }  
   1078               }
   1079               else if(blink_pos==5){  
   1080                    for(i=0; i<2; i++){                         
   1081                         setcursor(x+(x_tap*i), y+(8*7)+2);
   1082                         for(j=(temp5*16); j<(temp5*16)+8; j++){
   1083                              if(T_toggle)SendData(num[j+i*8]);
   1084                              else SendData(num[180+(a++)]);
   1085                         }
   1086                    }  
   1087               }
   1088               else if(blink_pos==6){  
   1089                    for(i=0; i<2; i++){                         
   1090                         setcursor(x+(x_tap*i), y+(8*6)+2);
   1091                         for(j=(temp6*16); j<(temp6*16)+8; j++){
   1092                              if(T_toggle)SendData(num[j+i*8]);
   1093                              else SendData(num[180+(a++)]);
   1094                         }
   1095                    }  
   1096               }
   1097                 else if(blink_pos==7){  
   1098                    for(i=0; i<2; i++){                         
   1099                         setcursor(x+(x_tap*i), y+(8*5)+2);
   1100                         for(j=(temp7*16); j<(temp7*16)+8; j++){
   1101                              if(T_toggle)SendData(num[j+i*8]);
   1102                              else SendData(num[180+(a++)]);
   1103                         }
   1104                    }  
   1105               }
   1106               else if(blink_pos==8){  
   1107                    for(i=0; i<2; i++){                         
   1108                         setcursor(x+(x_tap*i), y+(8*4)+2);
   1109                         for(j=(temp8*16); j<(temp8*16)+8; j++){
   1110                              if(T_toggle)SendData(num[j+i*8]);
   1111                              else SendData(num[180+(a++)]);
   1112                         }
   1113                    }  
   1114               }
   1115               else if(blink_pos==9){  
   1116                    for(i=0; i<2; i++){                         
   1117                         setcursor(x+(x_tap*i), y+(8*2));
   1118                         for(j=(temp9*16); j<(temp9*16)+8; j++){
   1119                              if(T_toggle)SendData(num[j+i*8]);
   1120                              else SendData(num[180+(a++)]);
   1121                         }
   1122                    }  
   1123               }
   1124               else if(blink_pos==10){  
   1125                    for(i=0; i<2; i++){                         
   1126                         setcursor(x+(x_tap*i), y+8);
   1127                         for(j=(temp10*16); j<(temp10*16)+8; j++){
   1128                              if(T_toggle)SendData(num[j+i*8]);
   1129                              else SendData(num[180+(a++)]);
   1130                         }
   1131                    }  
   1132               }
   1133               else if(blink_pos==11){  
   1134                    for(i=0; i<2; i++){                         
   1135                         setcursor(x+(x_tap*i), y);
   1136                         for(j=(temp11*16); j<(temp11*16)+8; j++){
   1137                              if(T_toggle)SendData(num[j+i*8]);
   1138                              else SendData(num[180+(a++)]);
   1139                         }
   1140                    }  
   1141               }     
   1142          }
   1143          
   1144          
   1145          void DIS_number(u8 x, u8 y, u8 temp1)
   1146          {
   1147            unsigned char i, j;  
   1148            
   1149              for(i=0; i<2; i++){                         
   1150                 setcursor(x+i, y);
   1151                 for(j=(temp1*16); j<(temp1*16)+8; j++)
   1152                      SendData(num[j+i*8]);
   1153             }	
   1154          }
   1155          
   1156          void DIS_blink(u8 x, u8 y)
   1157          {
   1158            unsigned char i, j;  
   1159            
   1160              for(i=0; i<2; i++){                         
   1161                 setcursor(x+i, y);
   1162                 for(j=0; j< 8; j++)
   1163                      SendData(0x00);
   1164             }	
   1165          }
   1166          
   1167          
   1168          void DIS_TGS_LEVEL(u8 x, u8 y, u8 temp2,u8 temp1, u8 pos)
   1169          {
   1170               unsigned char i, j, a;  
   1171            
   1172               a=0;
   1173              
   1174               if((pos==1)||(pos==2)){
   1175          	     if(pos==2){
   1176          	          for(i=0; i<2; i++){                         
   1177                              setcursor(x+i, y);
   1178                         	for(j=(temp2*16); j<(temp2*16)+8; j++){
   1179          				     if(T_toggle)SendData(num[j+i*8]);
   1180          				     else SendData(num[180+(a++)]);
   1181          				}				
   1182          			}
   1183          	     	for(i=0; i<2; i++){                         
   1184               	    		setcursor(x+i, y+8);
   1185          	         		for(j=(temp1*16); j<(temp1*16)+8; j++){
   1186               	         		SendData(num[j+i*8]);
   1187          				}
   1188          			}
   1189          
   1190          	     }
   1191          		else if(pos==1){   
   1192          	          for(i=0; i<2; i++){                         
   1193                              setcursor(x+i, y);
   1194                         	for(j=(temp2*16); j<(temp2*16)+8; j++)
   1195          				     SendData(num[j+i*8]);
   1196          			}
   1197          	     	for(i=0; i<2; i++){                         
   1198               	    		setcursor(x+i, y+8);
   1199          	         		for(j=(temp1*16); j<(temp1*16)+8; j++){
   1200               	         		if(T_toggle)SendData(num[j+i*8]);
   1201          				     else SendData(num[180+(a++)]);
   1202          				}
   1203          			}
   1204            	     }
   1205               }
   1206          	 
   1207               else{
   1208            	    for(i=0; i<2; i++){                         
   1209          		    setcursor(x+i, y);
   1210                        for(j=(temp2*16); j<(temp2*16)+8; j++)
   1211                        SendData(num[j+i*8]);
   1212            		}	
   1213             		for(i=0; i<2; i++){                         
   1214                 		setcursor(x+i, y+8);
   1215                 		for(j=(temp1*16); j<(temp1*16)+8; j++)
   1216                      	SendData(num[j+i*8]);
   1217          		}
   1218               }
   1219          
   1220          }
   1221          
   1222          void DIS_ADC(u8 x, u8 y, u8 temp4,u8 temp3, u8 temp2,u8 temp1)
   1223          {
   1224            unsigned char i, j;  
   1225            u8 tap;
   1226            
   1227            tap=8;
   1228          
   1229              for(i=0; i<2; i++){                         
   1230                 setcursor((x+(tap*i)), y);
   1231                 for(j=(temp4*16); j<(temp4*16)+8; j++)
   1232                      SendData(num[j+i*8]);
   1233             }	
   1234             for(i=0; i<2; i++){                         
   1235                 setcursor(x+(tap), y+6+8);
   1236                 for(j=(temp3*16); j<(temp3*16)+8; j++)
   1237                      SendData(num[j+i*8]);
   1238            }
   1239          
   1240            for(i=0; i<2; i++){                         
   1241                 setcursor(x+i, y);
   1242                 for(j=(temp2*16); j<(temp2*16)+8; j++)
   1243                      SendData(num[j+i*8]);
   1244            }	
   1245             for(i=0; i<2; i++){                         
   1246                 setcursor(x+i, y+6+8);
   1247                 for(j=(temp1*16); j<(temp1*16)+8; j++)
   1248                      SendData(num[j+i*8]);
   1249            }
   1250          
   1251          }
   1252          
   1253          void dis_volt(u8 x, u8 y, u8 temp2, u8 temp1, u8 temp0)
   1254          {
   1255             unsigned char i, j;  
   1256             u8 x_tap;
   1257             
   1258             x_tap=1;
   1259          
   1260             for(i=0; i<2; i++){                         
   1261                 setcursor(x+(x_tap*i), y);
   1262                 for(j=(temp2*16); j<(temp2*16)+8; j++)
   1263                      SendData(num[j+i*8]);
   1264             }	
   1265             for(i=0; i<2; i++){                         
   1266                 setcursor(x+(x_tap*i), y+8);
   1267                 for(j=160; j<168; j++)
   1268                     SendData(num[j+i*8]);
   1269             }
   1270          
   1271             for(i=0; i<2; i++){                         
   1272                 setcursor(x+(x_tap*i), y+8+8);
   1273                 for(j=(temp1*16); j<(temp1*16)+8; j++)
   1274                      SendData(num[j+i*8]);
   1275            }
   1276             for(i=0; i<2; i++){                         
   1277                 setcursor(x+(x_tap*i), y+8+8+8);
   1278                 for(j=(temp0*16); j<(temp0*16)+8; j++)
   1279                      SendData(num[j+i*8]);
   1280            }
   1281          }
   1282          
   1283          void dis_temp(u8 x, u8 y, u8 temp2, u8 temp1, u8 temp0)
   1284          {
   1285             unsigned char i, j;  
   1286             u8 x_tap;
   1287             
   1288             x_tap=1;
   1289          
   1290             for(i=0; i<2; i++){                         
   1291                 setcursor(x+(x_tap*i), y);
   1292                 for(j=(temp2*16); j<(temp2*16)+8; j++)
   1293                      SendData(num[j+i*8]);
   1294             }	
   1295             for(i=0; i<2; i++){                         
   1296                 setcursor(x+(x_tap*i), y+8);
   1297                 for(j=(temp1*16); j<(temp1*16)+8; j++)
   1298                      SendData(num[j+i*8]);
   1299            }
   1300             for(i=0; i<2; i++){                         
   1301                 setcursor(x+(x_tap*i), y+8+8);
   1302                 for(j=160; j<168; j++)
   1303                     SendData(num[j+i*8]);
   1304             }
   1305           
   1306             for(i=0; i<2; i++){                         
   1307                 setcursor(x+(x_tap*i), y+8+8+6);
   1308                 for(j=(temp0*16); j<(temp0*16)+8; j++)
   1309                      SendData(num[j+i*8]);
   1310            }
   1311          }
   1312          
   1313          void dis_humi(u8 x, u8 y, u8 temp2, u8 temp1, u8 temp0)
   1314          {
   1315             unsigned char i, j;  
   1316             u8 x_tap;
   1317             
   1318             x_tap=1;
   1319          
   1320             for(i=0; i<2; i++){                         
   1321                 setcursor(x+(x_tap*i), y);
   1322                 for(j=(temp2*16); j<(temp2*16)+8; j++)
   1323                      SendData(num[j+i*8]);
   1324             }	
   1325             for(i=0; i<2; i++){                         
   1326                 setcursor(x+(x_tap*i), y+8);
   1327                 for(j=(temp1*16); j<(temp1*16)+8; j++)
   1328                      SendData(num[j+i*8]);	  
   1329            }
   1330            for(i=0; i<2; i++){                         
   1331                 setcursor(x+(x_tap*i), y+8+8);
   1332                 for(j=160; j<168; j++)
   1333                     SendData(num[j+i*8]);
   1334             }  
   1335             for(i=0; i<2; i++){                         
   1336                 setcursor(x+(x_tap*i), y+8+8+6);
   1337                 for(j=(temp0*16); j<(temp0*16)+8; j++)
   1338                      SendData(num[j+i*8]);
   1339            }
   1340          }
   1341          /************************************************
   1342           CDMA 환경 설정을 위한 함수 
   1343          *************************************************/
   1344          void DIS_CDMA_Set(void)
   1345          {
   1346               u8 x,y;
   1347          
   1348               for(x=0;x<16;x++){
   1349                    setcursor(x,0);          // X position
   1350                
   1351                    for(y=0;y<240;y++){
   1352          	      SendData(cdma_status[y+x*240]);
   1353                    }
   1354                }  
   1355          }
   1356          
   1357          void DIS_ou(u8 x, u8 y, u8 temp5, u8 temp4, u8 temp3, u8 temp2, u8 temp1, u8 temp0)
   1358          {
   1359             unsigned char i, j;  
   1360             u8 x_tap;
   1361             
   1362             x_tap=1;
   1363          
   1364             for(i=0; i<2; i++){                         
   1365                 setcursor(x+(x_tap*i), y);
   1366                 for(j=(temp5*16); j<(temp5*16)+8; j++)
   1367                      SendData(num[j+i*8]);
   1368             }	
   1369             for(i=0; i<2; i++){                         
   1370                 setcursor(x+(x_tap*i), y+8);
   1371                 for(j=(temp4*16); j<(temp4*16)+8; j++)
   1372                      SendData(num[j+i*8]);
   1373             }	
   1374             for(i=0; i<2; i++){                         
   1375                 setcursor(x+(x_tap*i), y+(8*2));
   1376                 for(j=(temp3*16); j<(temp3*16)+8; j++)
   1377                      SendData(num[j+i*8]);
   1378             }	
   1379             for(i=0; i<2; i++){                         
   1380                 setcursor(x+(x_tap*i), (y+8*3));
   1381                 for(j=(temp2*16); j<(temp2*16)+8; j++)
   1382                      SendData(num[j+i*8]);
   1383             }	
   1384          
   1385             for(i=0; i<2; i++){                         
   1386                 setcursor(x+(x_tap*i), y+(8*4));
   1387                 for(j=160; j<168; j++)
   1388                     SendData(num[j+i*8]);
   1389             }
   1390             for(i=0; i<2; i++){                         
   1391                 setcursor(x+(x_tap*i), (y+(8*4)+6));
   1392                 for(j=(temp1*16); j<(temp1*16)+8; j++)
   1393                      SendData(num[j+i*8]);
   1394            }
   1395            for(i=0; i<2; i++){                         
   1396                 setcursor(x+(x_tap*i), (y+(8*5)+6));
   1397                 for(j=(temp0*16); j<(temp0*16)+8; j++)
   1398                      SendData(num[j+i*8]);
   1399            }
   1400          }
   1401          
   1402          void DIS_ol(u8 x, u8 y, u8 temp5, u8 temp4, u8 temp3, u8 temp2, u8 temp1)
   1403          {
   1404             unsigned char i, j;  
   1405             u8 x_tap;
   1406             
   1407             x_tap=1;
   1408          
   1409             for(i=0; i<2; i++){                         
   1410                 setcursor(x+(x_tap*i), y);
   1411                 for(j=(temp5*16); j<(temp5*16)+8; j++)
   1412                      SendData(num[j+i*8]);
   1413             }	
   1414             for(i=0; i<2; i++){                         
   1415                 setcursor(x+(x_tap*i), y+8);
   1416                 for(j=(temp4*16); j<(temp4*16)+8; j++)
   1417                      SendData(num[j+i*8]);
   1418             }	
   1419             for(i=0; i<2; i++){                         
   1420                 setcursor(x+(x_tap*i), y+(8*2));
   1421                 for(j=(temp3*16); j<(temp3*16)+8; j++)
   1422                      SendData(num[j+i*8]);
   1423             }	
   1424             for(i=0; i<2; i++){                         
   1425                 setcursor(x+(x_tap*i), (y+8*3));
   1426                 for(j=(temp2*16); j<(temp2*16)+8; j++)
   1427                      SendData(num[j+i*8]);
   1428             }	
   1429             for(i=0; i<2; i++){                         
   1430                 setcursor(x+(x_tap*i), (y+(8*4)));
   1431                 for(j=(temp1*16); j<(temp1*16)+8; j++)
   1432                      SendData(num[j+i*8]);
   1433            }
   1434          }
   1435          
   1436          void DIS_ppb(u8 x, u8 y, u8 temp5, u8 temp4, u8 temp3, u8 temp2, u8 temp1, u8 temp0)
   1437          {
   1438             unsigned char i, j;  
   1439             u8 x_tap;
   1440             
   1441             x_tap=1;
   1442          
   1443             for(i=0; i<2; i++){                         
   1444                 setcursor(x+(x_tap*i), y);
   1445                 for(j=(temp5*16); j<(temp5*16)+8; j++)
   1446                      SendData(num[j+i*8]);
   1447             }	
   1448             for(i=0; i<2; i++){                         
   1449                 setcursor(x+(x_tap*i), y+8);
   1450                 for(j=(temp4*16); j<(temp4*16)+8; j++)
   1451                      SendData(num[j+i*8]);
   1452             }	
   1453             for(i=0; i<2; i++){                         
   1454                 setcursor(x+(x_tap*i), y+(8*2));
   1455                 for(j=(temp3*16); j<(temp3*16)+8; j++)
   1456                      SendData(num[j+i*8]);
   1457             }	
   1458             for(i=0; i<2; i++){                         
   1459                 setcursor(x+(x_tap*i), (y+8*3));
   1460                 for(j=(temp2*16); j<(temp2*16)+8; j++)
   1461                      SendData(num[j+i*8]);
   1462             }	
   1463             for(i=0; i<2; i++){                         
   1464                 setcursor(x+(x_tap*i), (y+8*4));
   1465                 for(j=(temp1*16); j<(temp1*16)+8; j++)
   1466                      SendData(num[j+i*8]);
   1467            }
   1468            for(i=0; i<2; i++){                         
   1469                 setcursor(x+(x_tap*i), (y+8*5));
   1470                 for(j=(temp0*16); j<(temp0*16)+8; j++)
   1471                      SendData(num[j+i*8]);
   1472            }
   1473          }
   1474          
   1475          
   1476          void dis_res(u8 x, u8 y, u8 temp2, u8 temp1, u8 temp0)
   1477          {
   1478             unsigned char i, j;  
   1479             u8 x_tap;
   1480             
   1481             x_tap=1;
   1482          
   1483             for(i=0; i<2; i++){                         
   1484                 setcursor(x+(x_tap*i), y);
   1485                 for(j=(temp2*16); j<(temp2*16)+8; j++)
   1486                      SendData(num[j+i*8]);
   1487             }	
   1488          
   1489             for(i=0; i<2; i++){                         
   1490                 setcursor(x+(x_tap*i), y+8);
   1491                 for(j=(temp1*16); j<(temp1*16)+8; j++)
   1492                      SendData(num[j+i*8]);
   1493            }
   1494             for(i=0; i<2; i++){                         
   1495                 setcursor(x+(x_tap*i), y+8+8);
   1496                 for(j=160; j<168; j++)
   1497                     SendData(num[j+i*8]);
   1498             }
   1499            
   1500             for(i=0; i<2; i++){                         
   1501                 setcursor(x+(x_tap*i), y+8+8+6);
   1502                 for(j=(temp0*16); j<(temp0*16)+8; j++)
   1503                      SendData(num[j+i*8]);
   1504            }
   1505          }
   1506          
   1507          
   1508          void DIS_TGS_Base(u8 x, u8 y, u8 temp4, u8 temp3, u8 temp2, u8 temp1, u8 pos)
   1509          {
   1510             unsigned char i, j;  
   1511             u8 x_tap, a=0;
   1512             
   1513             x_tap=1;
   1514             a=0;
   1515          
   1516          
   1517            // else{
   1518          	   for(i=0; i<2; i++){                         
   1519               	  setcursor(x+(x_tap*i), y);
   1520          	       for(j=(temp4*16); j<(temp4*16)+8; j++){
   1521          		       if(pos==8){  
   1522          		            if(T_toggle)SendData(num[j+i*8]);
   1523          				  else SendData(num[180+(a++)]);
   1524          			  }
   1525               	       else SendData(num[j+i*8]);
   1526          		  }
   1527             	   }	
   1528          
   1529          	   for(i=0; i<2; i++){                         
   1530               	  setcursor(x+(x_tap*i), y+8);
   1531          	       for(j=(temp3*16); j<(temp3*16)+8; j++){
   1532          		       if(pos==7){
   1533          			       if(T_toggle)SendData(num[j+i*8]);
   1534          				  else SendData(num[180+(a++)]);
   1535          		       }
   1536          		       else  SendData(num[j+i*8]);
   1537          		  }
   1538            	   }
   1539             	   for(i=0; i<2; i++){                         
   1540                 	  setcursor(x+(x_tap*i), y+8+8);
   1541                 	  for(j=160; j<168; j++)
   1542                    	 SendData(num[j+i*8]);
   1543             	   }
   1544            
   1545             	  for(i=0; i<2; i++){                         
   1546                 	setcursor(x+(x_tap*i), y+8+8+6);
   1547                 	for(j=(temp2*16); j<(temp2*16)+8; j++){
   1548          		       if(pos==6){
   1549          			       if(T_toggle)SendData(num[j+i*8]);
   1550          				  else SendData(num[180+(a++)]);
   1551          		       }
   1552          		       else  SendData(num[j+i*8]);
   1553          		  }
   1554            	   }
   1555          
   1556             	  for(i=0; i<2; i++){                         
   1557                 	setcursor(x+(x_tap*i), y+8+8+8+6);
   1558                 	for(j=(temp1*16); j<(temp1*16)+8; j++){
   1559          		       if(pos==5){
   1560          			       if(T_toggle)SendData(num[j+i*8]);
   1561          				  else SendData(num[180+(a++)]);
   1562          		       }
   1563          		       else  SendData(num[j+i*8]);
   1564          		  }
   1565            	   }
   1566            //}
   1567               if((pos > 4)&&(pos<9)){
   1568          	
   1569             }
   1570            
   1571          }
   1572          
   1573          void DIS_GPS_NO(void)
   1574          {
   1575             u8 x,y;
   1576          
   1577             for(x=0;x<2;x++){
   1578                setcursor(x,0);          // X position
   1579                
   1580                for(y=0;y<118;y++){
   1581          	 	SendData(gps_no[y+x*118]);
   1582                }
   1583             }
   1584          }
   1585          
   1586          void DIS_CLEAR_GPS_NO(void)
   1587          {
   1588             u8 x,y;
   1589          
   1590             for(x=0;x<2;x++){
   1591                setcursor(x,0);          // X position
   1592                
   1593                for(y=0;y<118;y++){
   1594          	 	SendData(clr_gps_no[y+x*118]);
   1595                }
   1596             }
   1597          }
   1598          
   1599          void DIS_GPS_TIME(unsigned char hour10,unsigned char hour1,unsigned char min10,unsigned char min1,unsigned char sec10,unsigned char sec1)
   1600          {
   1601          	u8 x, y, i, j;  
   1602               u8 x_tap, y_tap;
   1603             
   1604               x_tap=1;	
   1605          	y_tap=8;
   1606          	x=0;
   1607          	y=6;
   1608            
   1609               for(i=0; i<2; i++){                         
   1610                   setcursor(x+(x_tap*i), y);
   1611                   for(j=(hour10*16); j<(hour10*16)+8; j++)
   1612                        SendData(num[j+i*8]);
   1613               }
   1614               for(i=0; i<2; i++){                         
   1615                   setcursor(x+(x_tap*i), y+y_tap);
   1616                   for(j=(hour1*16); j<(hour1*16)+8; j++)
   1617                        SendData(num[j+i*8]);
   1618               }   
   1619          	
   1620          	for(i=0; i<2; i++){                         
   1621                 setcursor(x+(x_tap*i), y+y_tap*2+2);
   1622                 for(j=176; j<178; j++)
   1623                     SendData(num[j+i*2]);
   1624               }
   1625          	
   1626          	///////////////////////////////////////////////////////
   1627             
   1628               for(i=0; i<2; i++){                         
   1629                   setcursor(x+(x_tap*i), y+y_tap*2+2+4);
   1630                   for(j=(min10*16); j<(min10*16)+8; j++)
   1631                        SendData(num[j+i*8]);
   1632               }
   1633               for(i=0; i<2; i++){                         
   1634                   setcursor(x+(x_tap*i), y+y_tap*3+2+4);
   1635                   for(j=(min1*16); j<(min1*16)+8; j++)
   1636                        SendData(num[j+i*8]);
   1637               } 
   1638          	
   1639          	for(i=0; i<2; i++){                         
   1640                 setcursor(x+(x_tap*i), y+y_tap*4+2+6);
   1641                 for(j=176; j<178; j++)
   1642                     SendData(num[j+i*2]);
   1643               }
   1644          	////////////////////////////////////////////////////////
   1645               for(i=0; i<2; i++){                         
   1646                   setcursor(x+(x_tap*i), y+y_tap*4+5+7);
   1647                   for(j=(sec10*16); j<(sec10*16)+8; j++)
   1648                        SendData(num[j+i*8]);
   1649               }
   1650               for(i=0; i<2; i++){                         
   1651                   setcursor(x+(x_tap*i), y+y_tap*5+12);
   1652                   for(j=(sec1*16); j<(sec1*16)+8; j++)
   1653                        SendData(num[j+i*8]);
   1654               } 	
   1655          }
   1656          
   1657          void DIS_Time_Set(void)
   1658          {
   1659             u8 x,y;
   1660          
   1661             for(x=0;x<16;x++){
   1662                setcursor(x,0);          // X position
   1663                
   1664                for(y=0;y<240;y++){
   1665          	 SendData(time_set[y+x*240]);
   1666                }
   1667             }
   1668          }
   1669          
   1670          void DIS_RTC_TIME(unsigned char hour10,unsigned char hour1,unsigned char min10,unsigned char min1,unsigned char sec10,unsigned char sec1)
   1671          {
   1672          	u8 x, y, i, j;  
   1673               u8 x_tap, y_tap;
   1674             
   1675               x_tap=1;	
   1676          	y_tap=8;
   1677          	x=0;
   1678          	y=6;	
   1679            
   1680               for(i=0; i<2; i++){                         
   1681                   setcursor(x+(x_tap*i), y);
   1682                   for(j=(hour10*16); j<(hour10*16)+8; j++)
   1683                        SendData(num[j+i*8]);
   1684               }
   1685               for(i=0; i<2; i++){                         
   1686                   setcursor(x+(x_tap*i), y+y_tap);
   1687                   for(j=(hour1*16); j<(hour1*16)+8; j++)
   1688                        SendData(num[j+i*8]);
   1689               }   
   1690          	
   1691          	for(i=0; i<2; i++){                         
   1692                 setcursor(x+(x_tap*i), y+y_tap*2+2);
   1693                 for(j=176; j<178; j++)
   1694                     SendData(num[j+i*2]);
   1695               }
   1696          	
   1697          	///////////////////////////////////////////////////////
   1698             
   1699               for(i=0; i<2; i++){                         
   1700                   setcursor(x+(x_tap*i), y+y_tap*2+2+4);
   1701                   for(j=(min10*16); j<(min10*16)+8; j++)
   1702                        SendData(num[j+i*8]);
   1703               }
   1704               for(i=0; i<2; i++){                         
   1705                   setcursor(x+(x_tap*i), y+y_tap*3+2+4);
   1706                   for(j=(min1*16); j<(min1*16)+8; j++)
   1707                        SendData(num[j+i*8]);
   1708               } 
   1709          	
   1710          	for(i=0; i<2; i++){                         
   1711                 setcursor(x+(x_tap*i), y+y_tap*4+2+6);
   1712                 for(j=176; j<178; j++)
   1713                     SendData(num[j+i*2]);
   1714               }
   1715          	////////////////////////////////////////////////////////
   1716               for(i=0; i<2; i++){                         
   1717                   setcursor(x+(x_tap*i), y+y_tap*4+5+7);
   1718                   for(j=(sec10*16); j<(sec10*16)+8; j++)
   1719                        SendData(num[j+i*8]);
   1720               }
   1721               for(i=0; i<2; i++){                         
   1722                   setcursor(x+(x_tap*i), y+y_tap*5+12);
   1723                   for(j=(sec1*16); j<(sec1*16)+8; j++)
   1724                        SendData(num[j+i*8]);
   1725               } 	
   1726          }
   1727          
   1728          void DIS_RTC_SET(int i_year, int i_month, int i_day, int i_hour, int i_min, int i_sec, u8 blink_pos)
   1729          {
   1730          	u8 x, y, i, j, a;  
   1731               u8 x_tap, y_tap;
   1732          	u8 y_4, y_3, y_2, y_1;
   1733          	u8 mon_2, mon_1;
   1734          	u8 day_2, day_1;
   1735          	u8 h_2, h_1, m_2, m_1, s_2, s_1;
   1736          	u16 dum;
   1737             
   1738               x_tap=1;	
   1739          	y_tap=8;
   1740          	x=8;
   1741          	y=9;
   1742          	a=0;
   1743          	
   1744          	y_4=i_year/1000;
   1745          	dum = i_year%1000;
   1746          	y_3=dum/100;
   1747          	dum = i_year%100;
   1748          	y_2= dum/10;
   1749          	y_1 = dum%10;
   1750          	
   1751          	mon_2 = i_month/10;
   1752          	mon_1 = i_month%10;
   1753          	day_2= i_day/10;
   1754          	day_1 = i_day%10;
   1755          	h_2 = i_hour/10;
   1756          	h_1 = i_hour%10;
   1757          	m_2 = i_min/10;
   1758          	m_1 = i_min%10;
   1759          	
   1760          	s_2 = i_sec/10;
   1761          	s_1 = i_sec%10;
   1762          	
   1763               for(i=0; i<2; i++){                         
   1764                   setcursor(x+(x_tap*i), y+2);
   1765                   for(j=(y_4*16); j<(y_4*16)+8; j++)
   1766                        SendData(num[j+i*8]);
   1767               }
   1768               for(i=0; i<2; i++){                         
   1769                   setcursor(x+(x_tap*i), y+2+y_tap);
   1770                   for(j=(y_3*16); j<(y_3*16)+8; j++)
   1771                        SendData(num[j+i*8]);
   1772               }   
   1773               for(i=0; i<2; i++){                         
   1774                   setcursor(x+(x_tap*i), y+2+(y_tap*2));
   1775                   for(j=(y_2*16); j<(y_2*16)+8; j++)
   1776                        SendData(num[j+i*8]);
   1777               }   
   1778               for(i=0; i<2; i++){                         
   1779                   setcursor(x+(x_tap*i), y+2+(y_tap*3));
   1780                   for(j=(y_1*16); j<(y_1*16)+8; j++)
   1781                        SendData(num[j+i*8]);
   1782               }   
   1783               //month
   1784               for(i=0; i<2; i++){                         
   1785                   setcursor(x+(x_tap*i), y+6+(y_tap*6));
   1786                   for(j=(mon_2*16); j<(mon_2*16)+8; j++)
   1787                        SendData(num[j+i*8]);
   1788               }
   1789               for(i=0; i<2; i++){                         
   1790                   setcursor(x+(x_tap*i), y+6+(y_tap*7));
   1791                   for(j=(mon_1*16); j<(mon_1*16)+8; j++)
   1792                        SendData(num[j+i*8]);
   1793               }
   1794                // day
   1795               for(i=0; i<2; i++){                         
   1796                   setcursor(x+(x_tap*i), y+(y_tap*11));
   1797                   for(j=(day_2*16); j<(day_2*16)+8; j++)
   1798                        SendData(num[j+i*8]);
   1799               }
   1800               for(i=0; i<2; i++){                         
   1801                   setcursor(x+(x_tap*i), y+(y_tap*12));
   1802                   for(j=(day_1*16); j<(day_1*16)+8; j++)
   1803                        SendData(num[j+i*8]);
   1804               }
   1805          	// hour
   1806               for(i=0; i<2; i++){                         
   1807                   setcursor(x+(x_tap*i), y+4+(y_tap*15));
   1808                   for(j=(h_2*16); j<(h_2*16)+8; j++)
   1809                        SendData(num[j+i*8]);
   1810               }
   1811               for(i=0; i<2; i++){                         
   1812                   setcursor(x+(x_tap*i), y+4+(y_tap*16));
   1813                   for(j=(h_1*16); j<(h_1*16)+8; j++)
   1814                        SendData(num[j+i*8]);
   1815               }
   1816          	// minute
   1817               for(i=0; i<2; i++){                         
   1818                   setcursor(x+(x_tap*i), y+6+(y_tap*19));
   1819                   for(j=(m_2*16); j<(m_2*16)+8; j++)
   1820                        SendData(num[j+i*8]);
   1821               }
   1822               for(i=0; i<2; i++){                         
   1823                   setcursor(x+(x_tap*i), y+6+(y_tap*20));
   1824                   for(j=(m_1*16); j<(m_1*16)+8; j++)
   1825                        SendData(num[j+i*8]);
   1826               }
   1827          	// second
   1828               for(i=0; i<2; i++){                         
   1829                   setcursor(x+(x_tap*i), y+(y_tap*24));
   1830                   for(j=(s_2*16); j<(s_2*16)+8; j++)
   1831                        SendData(num[j+i*8]);
   1832               }
   1833               for(i=0; i<2; i++){                         
   1834                   setcursor(x+(x_tap*i), y+(y_tap*25));
   1835                   for(j=(s_1*16); j<(s_1*16)+8; j++)
   1836                        SendData(num[j+i*8]);
   1837               }
   1838          	
   1839          	
   1840          	if(blink_pos==1){  
   1841                    for(i=0; i<2; i++){                         
   1842                         setcursor(x+(x_tap*i), y+(y_tap*25));
   1843                         for(j=(s_1*16); j<(s_1*16)+8; j++){
   1844                              if(T_toggle)SendData(num[j+i*8]);
   1845                              else SendData(num[180+(a++)]);
   1846                         }
   1847                    }  
   1848               }
   1849          	else if(blink_pos==2){  
   1850                    for(i=0; i<2; i++){                         
   1851                          setcursor(x+(x_tap*i), y+(y_tap*24));
   1852                         for(j=(s_2*16); j<(s_2*16)+8; j++){
   1853                              if(T_toggle)SendData(num[j+i*8]);
   1854                              else SendData(num[180+(a++)]);
   1855                         }
   1856                    }  
   1857               }
   1858          	else if(blink_pos==3){  
   1859                    for(i=0; i<2; i++){                         
   1860                          setcursor(x+(x_tap*i), y+6+(y_tap*20));
   1861          			 for(j=(m_1*16); j<(m_1*16)+8; j++){
   1862                              if(T_toggle)SendData(num[j+i*8]);
   1863                              else SendData(num[180+(a++)]);
   1864                         }
   1865                    }  
   1866               }
   1867          	else if(blink_pos==4){  
   1868                    for(i=0; i<2; i++){                         
   1869                           setcursor(x+(x_tap*i), y+6+(y_tap*19));
   1870                  		  for(j=(m_2*16); j<(m_2*16)+8; j++){
   1871                              if(T_toggle)SendData(num[j+i*8]);
   1872                              else SendData(num[180+(a++)]);
   1873                         }
   1874                    }  
   1875               }
   1876          	else if(blink_pos==5){  
   1877                    for(i=0; i<2; i++){                         
   1878                           setcursor(x+(x_tap*i), y+4+(y_tap*16));
   1879                   	       for(j=(h_1*16); j<(h_1*16)+8; j++){
   1880                              if(T_toggle)SendData(num[j+i*8]);
   1881                              else SendData(num[180+(a++)]);
   1882                         }
   1883                    }  
   1884               }
   1885          	else if(blink_pos==6){  
   1886                    for(i=0; i<2; i++){                         
   1887                           setcursor(x+(x_tap*i), y+4+(y_tap*15));
   1888                	       for(j=(h_2*16); j<(h_2*16)+8; j++){
   1889                              if(T_toggle)SendData(num[j+i*8]);
   1890                              else SendData(num[180+(a++)]);
   1891                         }
   1892                    }  
   1893               }
   1894          	else if(blink_pos==7){  
   1895                    for(i=0; i<2; i++){                         
   1896                          setcursor(x+(x_tap*i), y+(y_tap*12));
   1897                  		 for(j=(day_1*16); j<(day_1*16)+8; j++){
   1898                              if(T_toggle)SendData(num[j+i*8]);
   1899                              else SendData(num[180+(a++)]);
   1900                         }
   1901                    }  
   1902               }
   1903          	else if(blink_pos==8){  
   1904                    for(i=0; i<2; i++){                         
   1905                          setcursor(x+(x_tap*i), y+(y_tap*11));
   1906                  		 for(j=(day_2*16); j<(day_2*16)+8; j++){
   1907                              if(T_toggle)SendData(num[j+i*8]);
   1908                              else SendData(num[180+(a++)]);
   1909                         }
   1910                    }  
   1911               }
   1912          	else if(blink_pos==9){  
   1913                    for(i=0; i<2; i++){                         
   1914                           setcursor(x+(x_tap*i), y+6+(y_tap*7));
   1915          			  for(j=(mon_1*16); j<(mon_1*16)+8; j++){
   1916                              if(T_toggle)SendData(num[j+i*8]);
   1917                              else SendData(num[180+(a++)]);
   1918                         }
   1919                    }  
   1920               }
   1921          	else if(blink_pos==10){  
   1922                    for(i=0; i<2; i++){                         
   1923                           setcursor(x+(x_tap*i), y+6+(y_tap*6));
   1924                   		  for(j=(mon_2*16); j<(mon_2*16)+8; j++){
   1925                              if(T_toggle)SendData(num[j+i*8]);
   1926                              else SendData(num[180+(a++)]);
   1927                         }
   1928                    }  
   1929               }
   1930          	else if(blink_pos==11){  
   1931                    for(i=0; i<2; i++){                         
   1932                            setcursor(x+(x_tap*i), y+2+(y_tap*3));
   1933          			   for(j=(y_1*16); j<(y_1*16)+8; j++){
   1934                              if(T_toggle)SendData(num[j+i*8]);
   1935                              else SendData(num[180+(a++)]);
   1936                         }
   1937                    }  
   1938               }
   1939          	else if(blink_pos==12){  
   1940                    for(i=0; i<2; i++){                         
   1941                           setcursor(x+(x_tap*i), y+2+(y_tap*2));
   1942                  		  for(j=(y_2*16); j<(y_2*16)+8; j++){
   1943                              if(T_toggle)SendData(num[j+i*8]);
   1944                              else SendData(num[180+(a++)]);
   1945                         }
   1946                    }  
   1947               }
   1948          	else if(blink_pos==13){  
   1949                    for(i=0; i<2; i++){                         
   1950                           setcursor(x+(x_tap*i), y+2+y_tap);
   1951                  		  for(j=(y_3*16); j<(y_3*16)+8; j++){
   1952                              if(T_toggle)SendData(num[j+i*8]);
   1953                              else SendData(num[180+(a++)]);
   1954                         }
   1955                    }  
   1956               }
   1957          	else if(blink_pos==14){  
   1958                    for(i=0; i<2; i++){                         
   1959                           setcursor(x+(x_tap*i), y+2);
   1960                  		  for(j=(y_4*16); j<(y_4*16)+8; j++){
   1961                              if(T_toggle)SendData(num[j+i*8]);
   1962                              else SendData(num[180+(a++)]);
   1963                         }
   1964                    }  
   1965               }
   1966          	
   1967          } 
   1968          
   1969          void dis_all(void)
   1970          	{
   1971          		u8 x,y;
   1972          
   1973          		for(x=0;x<16;x++)			
   1974          		{
   1975          			setcursor(x,0);
   1976          			for(y=0;y<120;y++) 		   
   1977          			{
   1978          				SendData(0xff);			
   1979          				SendData(0x00);
   1980          			}
   1981          		}
   1982          	}
   1983          
   1984          void dis_dot(void)
   1985          	{
   1986          		u8 i,x,y,dat1,dat2;
   1987          
   1988          		dat1=0x55;
   1989          		dat2=0xAA;
   1990          
   1991          		for(i=0;i<2;i++)
   1992          		{
   1993          			for(x=0;x<16;x++)				
   1994          			{
   1995          				setcursor(x,0);
   1996          				for(y=0;y<120;y++) 		    
   1997          				{
   1998          					SendData(dat1);			
   1999          					SendData(dat2);
   2000          				}
   2001          			}
   2002          		delay_tst(50);
   2003          			dat1=~dat1;
   2004          			dat2=~dat2;
   2005          		}		
   2006          	}
   2007          
   2008          void dis_col(void)
   2009          	{ 
   2010          		u8 i,x,y,dat1,dat2;
   2011          
   2012          		dat1=0xFF;
   2013          		dat2=0x00;
   2014          
   2015          		for(i=0;i<2;i++)
   2016          		{
   2017          			for(x=0;x<16;x++)				
   2018          			{
   2019          				setcursor(x,0);
   2020          				for(y=0;y<120;y++) 		   
   2021          				{
   2022          					SendData(dat1);			
   2023          					SendData(dat2);
   2024          				}
   2025          			}
   2026          			delay_tst(50);
   2027          			dat1=~dat1;
   2028          			dat2=~dat2;
   2029          		}			
   2030          	}
   2031          
   2032          
   2033          void one_word(u8 x,u8 y,u8 *Lib,u8 ch_num,u8 widthw)
   2034          	{
   2035          		u8 i,j,row,col;
   2036          		u16 xi;									
   2037          		
   2038          		xi=ch_num * widthw;						
   2039          		if (widthw==8)
   2040          		{row=1;col=8;}
   2041          		else {row=2; col=widthw>>1;}
   2042          		for(i=0;i<row;i++)
   2043          		{
   2044          			setcursor(x,y);
   2045          			for(j=0;j<col;j++)
   2046          			{
   2047          				SendData(Lib[xi]);				
   2048          				xi++;
   2049          				y++;
   2050          				if (y==240){y=0;x+=row;}	
   2051          				if (x>15) x=0;				
   2052          			}									
   2053          			x++;							
   2054          			y=y-col;	
   2055          		}
   2056          	}
   2057          	
   2058          								
   2059          	
   2060          
   2061          
   2062          
   2063          
   2064          
   2065          
   2066          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       40  DIS_ADC
              40 -> SendData
              40 -> setcursor
       16  DIS_CDMA_Set
              16 -> SendData
              16 -> setcursor
       16  DIS_CLEAR_GPS_NO
              16 -> SendData
              16 -> setcursor
       16  DIS_Comm_Set
              16 -> SendData
              16 -> setcursor
       16  DIS_FUN_H2S
              16 -> SendData
              16 -> setcursor
       16  DIS_FUN_NH3
              16 -> SendData
              16 -> setcursor
       16  DIS_FUN_PID
              16 -> SendData
              16 -> setcursor
       16  DIS_FUN_TBM
              16 -> SendData
              16 -> setcursor
       16  DIS_FUN_VOC
              16 -> SendData
              16 -> setcursor
       16  DIS_GPS_NO
              16 -> SendData
              16 -> setcursor
        0  DIS_GPS_TIME
              32 -> SendData
              32 -> setcursor
       16  DIS_High_Set_Menu
              16 -> SendData
              16 -> setcursor
       16  DIS_Measure_m
              16 -> SendData
              16 -> setcursor
       16  DIS_Measure_ou
              16 -> SendData
              16 -> setcursor
       16  DIS_Menu
              16 -> SendData
              16 -> setcursor
       16  DIS_Modify_set_Menu
              16 -> SendData
              16 -> setcursor
       16  DIS_Mos_set_Menu
              16 -> SendData
              16 -> setcursor
       16  DIS_Normal_Set_Menu
              16 -> SendData
              16 -> setcursor
       16  DIS_PV_Set
              16 -> SendData
              16 -> setcursor
      112  DIS_RTC_SET
             112 -> SendData
             112 -> setcursor
        0  DIS_RTC_TIME
              32 -> SendData
              32 -> setcursor
       48  DIS_TGS_Base
              48 -> SendData
              48 -> setcursor
       56  DIS_TGS_LEVEL
              56 -> SendData
              56 -> setcursor
       72  DIS_TGS_abcde
              72 -> SendData
              72 -> setcursor
       16  DIS_Time_Set
              16 -> SendData
              16 -> setcursor
       16  DIS_Volt
              16 -> SendData
              16 -> setcursor
       16  DIS_abnormal
              16 -> SendData
              16 -> setcursor
       24  DIS_blink
              24 -> SendData
              24 -> setcursor
       16  DIS_continue
              16 -> SendData
              16 -> setcursor
       16  DIS_continue_m
              16 -> SendData
              16 -> setcursor
       16  DIS_duration
              16 -> SendData
              16 -> setcursor
       16  DIS_duration_m
              16 -> SendData
              16 -> setcursor
       16  DIS_normal
              16 -> SendData
              16 -> setcursor
       32  DIS_number
              32 -> SendData
              32 -> setcursor
       32  DIS_ol
              32 -> SendData
              32 -> setcursor
       32  DIS_ou
              32 -> SendData
              32 -> setcursor
       32  DIS_ppb
              32 -> SendData
              32 -> setcursor
       16  DIS_ready
              16 -> SendData
              16 -> setcursor
       16  DIS_real
              16 -> SendData
              16 -> setcursor
       16  DIS_real_m
              16 -> SendData
              16 -> setcursor
       16  DIS_run
              16 -> SendData
              16 -> setcursor
       88  Dis_CDMA_Num
              88 -> SendData
              88 -> setcursor
        0  Dis_CDMA_Time
              56 -> SendData
              56 -> setcursor
       56  Dis_OLUF
              56 -> SendData
              56 -> setcursor
        0  Dis_Sample_Time
              56 -> SendData
              56 -> setcursor
       32  Dis_Timer3
              32 -> SendData
              32 -> setcursor
       16  SendCtrl
               0 -> GPIO_ResetBits
              16 -> GPIO_ResetBits
              16 -> GPIO_SetBits
              16 -> SPI_I2S_GetFlagStatus
              16 -> SPI_I2S_SendData
              16 -> SPI_Normal_mode
              16 -> SPI_Spi_mode
       16  SendData
               0 -> GPIO_ResetBits
              16 -> GPIO_ResetBits
              16 -> GPIO_SetBits
              16 -> SPI_I2S_GetFlagStatus
              16 -> SPI_I2S_SendData
              16 -> SPI_Normal_mode
              16 -> SPI_Spi_mode
       16  clr_screen
              16 -> SendData
              16 -> setcursor
        0  delay_tst
       16  dis_all
              16 -> SendData
              16 -> setcursor
       24  dis_col
              24 -> SendData
              24 -> delay_tst
              24 -> setcursor
       24  dis_dot
              24 -> SendData
              24 -> delay_tst
              24 -> setcursor
        0  dis_humi
              32 -> SendData
              32 -> setcursor
       16  dis_logo
              16 -> SendData
              16 -> setcursor
       16  dis_measure
              16 -> SendData
              16 -> setcursor
        0  dis_res
              32 -> SendData
              32 -> setcursor
       32  dis_sign
              32 -> SendData
              32 -> setcursor
        0  dis_temp
              32 -> SendData
              32 -> setcursor
       32  dis_volt
              32 -> SendData
              32 -> setcursor
        8  lcd_init
               8 -> Delay
               0 -> SendCtrl
               8 -> SendCtrl
       40  one_word
              40 -> SendData
              40 -> setcursor
        8  setcursor
               0 -> SendCtrl
               8 -> SendCtrl


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable35
       4  ??DataTable40
       4  ??DataTable41
       4  ??DataTable42
       4  ??DataTable43
       4  ??DataTable43_1
       4  ??DataTable45
       6  ??Subroutine40_0
      82  ?Subroutine0
       6  ?Subroutine1
     188  ?Subroutine10
      62  ?Subroutine11
      10  ?Subroutine12
       8  ?Subroutine13
       6  ?Subroutine14
      12  ?Subroutine15
      12  ?Subroutine16
      10  ?Subroutine17
       6  ?Subroutine18
      10  ?Subroutine19
      32  ?Subroutine2
      12  ?Subroutine20
      10  ?Subroutine21
      10  ?Subroutine22
      10  ?Subroutine23
      10  ?Subroutine24
      10  ?Subroutine25
      10  ?Subroutine26
      18  ?Subroutine27
      14  ?Subroutine28
      10  ?Subroutine29
      30  ?Subroutine3
      12  ?Subroutine30
       8  ?Subroutine31
       8  ?Subroutine32
       8  ?Subroutine33
      10  ?Subroutine34
      10  ?Subroutine35
      10  ?Subroutine36
       8  ?Subroutine37
       8  ?Subroutine38
      10  ?Subroutine39
      30  ?Subroutine4
      28  ?Subroutine5
      28  ?Subroutine6
      28  ?Subroutine7
     390  ?Subroutine8
     356  ?Subroutine9
     200  DIS_ADC
      12  DIS_CDMA_Set
       8  DIS_CLEAR_GPS_NO
      12  DIS_Comm_Set
      12  DIS_FUN_H2S
      12  DIS_FUN_NH3
      12  DIS_FUN_PID
      12  DIS_FUN_TBM
      12  DIS_FUN_VOC
      10  DIS_GPS_NO
       2  DIS_GPS_TIME
      12  DIS_High_Set_Menu
      12  DIS_Measure_m
      12  DIS_Measure_ou
      12  DIS_Menu
      12  DIS_Modify_set_Menu
      12  DIS_Mos_set_Menu
      12  DIS_Normal_Set_Menu
      12  DIS_PV_Set
    1908  DIS_RTC_SET
       2  DIS_RTC_TIME
     384  DIS_TGS_Base
     326  DIS_TGS_LEVEL
     772  DIS_TGS_abcde
      12  DIS_Time_Set
      12  DIS_Volt
       8  DIS_abnormal
      34  DIS_blink
      10  DIS_continue
      10  DIS_continue_m
       8  DIS_duration
       8  DIS_duration_m
      10  DIS_normal
      62  DIS_number
     212  DIS_ol
     282  DIS_ou
     254  DIS_ppb
      10  DIS_ready
      10  DIS_real
      10  DIS_real_m
       8  DIS_run
    1296  Dis_CDMA_Num
       2  Dis_CDMA_Time
     444  Dis_OLUF
       4  Dis_Sample_Time
     144  Dis_Timer3
    3840  High_menu
    3840  LOGO_1
    3840  Normal_menu
    3840  PV_Set
      24  Plus
      28  SendCtrl
      24  SendData
     100  abnormal
    3840  cdma_status
     236  clr_gps_no
      34  clr_screen
    3840  comm_set
      92  continue_1
     188  continue_m
      12  delay_tst
      36  dis_all
       8  dis_col
      10  dis_dot
       2  dis_humi
      12  dis_logo
       8  dis_measure
       4  dis_res
      94  dis_sign
       2  dis_temp
     164  dis_volt
      92  duration
     188  duration_m
    3840  fun_H2S
    3840  fun_NH3
    3840  fun_PID
    3840  fun_TBM
    3840  fun_voc
     236  gps_no
      86  lcd_init
      96  m_ready
      96  m_run
    3840  measure_m
    3840  menu
    3840  modify_menu
    3840  mos_set
     100  normal
     208  num
     112  one_word
      92  real
     188  real_m
    3840  sensor_m
    3840  sensor_ou_2
    3840  sensor_volt
      28  setcursor
    3840  time_set

 
 83 784 bytes in section .text
 
 83 784 bytes of CODE memory

Errors: none
Warnings: none
